Parametry symulacji:

1. -S: `A^{1e5}`
2. -d: `1`
3. -K: `50`
4. -a (alpha): `0.005`
5. -f: element `{1.0, 2.0}` (stosowałam w samym skrypcie odwrotną transformację: `(d, K) -> (d*f, K/f)`, ponieważ łatwiej było mi znaleźć parametry dla dużych `K` i małych `d`)

Przy transformacji `(d, K) -> (d/f, K*f)` zachowujemy łączną liczbę kroków symulacji - `d/f * K*f = Kd`. Niech `T(K, d) = <0..Kd - 1>` będzie ciągiem czasów symulacji. Przez `T_P(K, d) = <t : T(K, d) | t = 0 mod d>` oznaczmy ciąg czasów pomiaru danych do wykresu. Oczywiście `|T_P(K, d)| = floor(|T(K, d)| / d) = K`. Dlatego przy transformacji `(d, K) -> (d/f, K*f)` otrzymujemy `|T_P(K*f, d/f)| = floor(|T(K*f, d/f)| * f / d) = floor(K * d * f / d) = floor(Kf)`.

Dla przypadku `f = 2` z polecenia, obserwujemy więc 2-krotne zwiększenie ilości punktów na wykresie (wykres lewy).

Oczywiście nie wpływa to nijak na symulację, ponieważ wciąż wykonujemy każdy z `Kd` kroków oraz zaczynamy z tej samej sekwencji początkowej. Dla dłuższych sekwencji, wykresy te są z dużym prawdopodobieństwem do siebie bardzo podobne, więc dla wystarczająco długich sekwencji, są one niemal identyczne (wykres prawy).
